<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple Chat</title>
</head>
<style>
  #chat-con{
    width: 520px;
    height: 500px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  #chat-log{
    border: 1px solid #ccc;
    padding: 10px;
    list-style: none;
    overflow-y: auto;
    scroll-behavior: smooth;
  }
  li {
    margin-bottom: 8px;
    padding: 5px;
    border: 1px solid #eee;
  }
  #box {
    margin-top: 5px;
    height: 20px;
    font: 16px Consolas bold;
  }
  #namebox{
    margin-top: 5px;
    height: 20px;
    font: 16px Consolas bold;
  }

  #button {
    padding-top: 5px;
  }
</style>
</html>
<body>
  <p id="output">여기에 응답 표시</p>
  <div id="chat-con">
    <ul id="chat-log"></ul>
  </div>
  <input type="text" size=2 id="namebox" name="namebox">
  <input type="text" size=40 id="box" name="box" placeholder="메시지 입력">
  <button id="button" onclick=send()>보내기</button>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.js"></script>
<script>
  let server = "10.50.131.25:8080";

  // 기존 스크립트 시작 부분에 변수 선언 추가
  let stompClient = null;
  let username = ""; // 사용자 이름을 고정하거나 입력받도록 조정

  // ... 기존 p, chatLogElement, box, button 변수들 ...
  const messageInput = document.getElementById('box'); // 기존 id "box" 사용
  const sendButton = document.getElementById('button'); // 기존 id "button" 사용
  const chatLogElement = document.getElementById('chat-log'); // 기존 id "chat-log" 사용
  const nameboxInput = document.getElementById('namebox');


  // --- WebSocket/STOMP 관련 함수 추가 시작 ---

  // 웹소켓 연결 시작 (페이지 로드 또는 특정 버튼 클릭 시 호출)
  function connect() {
    // 이 예제에서는 사용자 이름을 "client"로 고정했지만, 실제로는 입력받아 사용
    // username = document.getElementById('usernameInput').value.trim(); // 사용자 입력 시 활성화

    console.log("WebSocket 연결 시도...");
    var socket = new SockJS('http://'+server+'/ws');
    stompClient = Stomp.over(socket);

    // STOMP 클라이언트 연결
    // 연결 성공 시 onConnected 호출, 실패 시 onError 호출
    stompClient.connect({}, onConnected, onError);
  }

  // STOMP 연결 성공 시 호출되는 콜백 함수
  function onConnected() {
    console.log("WebSocket 연결 성공!");
    document.getElementById("output").textContent = "서버 응답: WebSocket 연결됨"; // 상태 표시 업데이트

    // 1. 공용 채팅 토픽 구독: 서버가 /topic/public으로 보내는 모든 새 메시지를 수신
    stompClient.subscribe('/topic/public', onMessageReceived);
    stompClient.subscribe('/topic/nick/', onNickChanged);

    // (선택 사항) 서버에 사용자 등록 메시지 전송 (세션에 사용자 이름 저장용)
    // 백엔드 ChatStompController의 @MessageMapping("/chat.addUser")를 사용한다면
    // stompClient.send("/app/chat.addUser", {}, JSON.stringify({ sender: username }));

    // 초기 채팅 내역은 기존 getChat() 함수 (fetch)를 통해 가져옵니다.
    getChat("http://"+server+"/init");
  }

  // STOMP 연결 실패 시 호출되는 콜백 함수
  function onError(error) {
    console.error("WebSocket 연결 실패:", error);
    document.getElementById("output").textContent = "서버 응답: WebSocket 연결 실패. " + error;
  }

  // 웹소켓을 통해 새 메시지를 받았을 때 호출되는 함수
  function onMessageReceived(payload) {
    const message = JSON.parse(payload.body);
    console.log("웹소켓으로 새 메시지 수신:", message);
    displayMessage(message); // 받은 메시지를 화면에 표시
  }

  function onNickChanged(payload){
    const flag = payload.body;
    console.log("웹소켓으로 새 메시지 수신:", flag);
    if( flag.includes(username) ) {
      if (flag.split('/')[1] === "1") {
        nameboxInput.value = username;
        alert("중복닉네임 입니다.");
      } else
        username = nameboxInput.value;
    }
  }

  // 화면에 메시지를 표시하는 범용 함수
  // 기존 getChat의 forEach 루프와 onMessageReceived에서 모두 사용하도록 함수 분리
  function displayMessage(message) {
    const listItem = document.createElement('li'); // 새로운 <li> 요소 생성
    const formattedChat = message.chat.replace(/\n/g, '<br>');

    // 메시지 형식 (sender가 있는 경우)
    if (message.sender) {
      listItem.innerHTML = `<strong>${message.sender}:</strong> ${formattedChat}`;
    } else { // sender 정보가 없는 경우 (기존 코드의 `id`가 sender 역할이었을 수 있음)
      listItem.innerHTML = `<strong>${message.id || '알 수 없음'}:</strong> ${formattedChat}`;
    }

    chatLogElement.appendChild(listItem); // ul에 li 추가
    chatLogElement.scrollTop = chatLogElement.scrollHeight; // 스크롤을 항상 최하단으로 내립니다.
  }
  // --- WebSocket/STOMP 관련 함수 추가 끝 ---


  // --- 기존 getChat 함수 수정 ---
  // 이제 이 함수는 초기 메시지 로딩 시 한 번만 호출됩니다.
  // 기존의 `p.textContent = "서버 응답: " + data;` 부분은 웹소켓 연결 상태를 표시하는 것으로 대체될 수 있습니다.
  // function getChat(url="http://localhost:8080/init"){ // URL을 /init으로 고정
  //   fetch(url)
  //           .then(response => response.json()) // JSON 응답을 기대
  //           .then(data => {
  //             // p.textContent = "서버 응답: " + data.length + "개 초기 메시지"; // 상태창은 웹소켓이 관리
  //             // 기존 메시지들 비우고 다시 로드 (선택 사항: 아니면 새로고침 없이 계속 쌓이도록)
  //             chatLogElement.innerHTML = '';
  //             data.forEach(message => {
  //               displayMessage(message); // 받은 메시지를 화면에 표시
  //             });
  //           })
  //           .catch(error => console.error('Error fetching initial chat history:', error));
  // }
  function getChat(url = "http://"+server+"/init") {
    // POST 요청에 보낼 데이터를 객체로 정의합니다.
    // 이 예시에서는 빈 객체를 보냅니다.
    // 실제 서버 로직에 따라 필요한 데이터를 추가할 수 있습니다.
    const requestBody = {};

    fetch(url, {
      method: 'POST', // HTTP 요청 메서드를 POST로 지정합니다.
      headers: {
        'Content-Type': 'application/json' // 서버에 JSON 데이터를 보낼 것임을 알립니다.
        // 필요하다면 다른 헤더 (예: 'Authorization')를 추가할 수 있습니다.
      },
      body: JSON.stringify(requestBody) // JavaScript 객체를 JSON 문자열로 변환하여 요청 본문에 담습니다.
    })
      .then(response => {
        // 응답이 성공적인지 확인합니다 (HTTP 상태 코드 200-299).
        if (!response.ok) {
          // 응답이 실패하면 에러를 던져 .catch 블록으로 넘깁니다.
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json(); // JSON 응답을 기대
      })
      .then(data => {
        // chatLogElement는 HTML에 존재하는 채팅 로그를 표시할 요소여야 합니다.
        // 예를 들어, const chatLogElement = document.getElementById('chat-log');
        chatLogElement.innerHTML = ''; // 기존 메시지들 비우고 다시 로드
        data.forEach(message => {
          if( message.id === "Anonymous" ) {
            nameboxInput.value = message.chat;
            username = message.chat;
          }
          else
            displayMessage(message); // 받은 메시지를 화면에 표시 (displayMessage 함수는 별도로 정의되어 있어야 함)
        });
      })
      .catch(error => console.error('Error fetching initial chat history:', error));
  }


  // --- 기존 send 함수는 그대로 유지 (HTTP POST로 메시지 전송) ---
  function send(){
    const response = fetch('http://'+server+'/chat', {    // chat = 방 이름
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        id: nameboxInput.value,
        message: document.getElementById('box').value // "message"는 서버 컨트롤러의 @RequestParam 이름과 일치
      })
    });

    document.getElementById("box").value = "";
  }

  function nick(){
    const response = fetch('http://'+server+'/chat/nick', {    // chat = 방 이름
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        oldnick: username,
        nick: nameboxInput.value // "nick"는 서버 컨트롤러의 @RequestParam 이름과 일치
      })
    });
  }

  // --- 이벤트 리스너 및 초기 호출 ---
  document.getElementById('box').addEventListener('keydown', (event) => {
    if (event.key === 'Enter')
      send();
  });

  document.getElementById('namebox').addEventListener('keydown', (event) => {
    if (event.key === 'Enter' || event.keyCode === 13) {
      document.getElementById('namebox').blur();
    }
  });

  document.getElementById('namebox').addEventListener('change', (event) => {
      // /chat/nick 보내기
      nick();
  });

  // 페이지 로드 시 웹소켓 연결 시작
  document.addEventListener('DOMContentLoaded', connect); // 이제 페이지 로드 시 바로 연결 시작
  // setInterval(getChat, 1000); // 숏폴링은 이제 사용하지 않음
</script>