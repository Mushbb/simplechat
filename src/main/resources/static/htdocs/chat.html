<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simple Chat</title>
</head>
<style>
    body {
        display: flex; /* Flexbox 레이아웃으로 채팅 영역과 유저 리스트 나란히 배치 */
        flex-direction: row; /* 채팅창과 유저리스트를 가로로 나열 */
        margin: 0;
        padding: 10px; /* 전체적인 여백 */
        height: calc(100vh - 20px); /* 뷰포트 높이에서 패딩 제외 */
        box-sizing: border-box; /* 패딩을 너비/높이에 포함 */
    }

    /* 기존 요소들 (p#output, a)은 채팅창 영역 밖으로 뺍니다 */
    #top-info-area {
        position: absolute; /* 절대 위치로 기존 정보 표시 영역 분리 */
        flex-direction: column; /* 세로로 나열 */
        top: 10px;
        left: 10px;
        z-index: 10;
        display: flex; /* 자식 요소들을 정렬하기 위해 flex 사용 */
        align-items: flex-start; /* 왼쪽 정렬 */
    }

    #chat-main-container {
        display: flex; /* 채팅 컨테이너와 유저 리스트를 나란히 */
        flex-grow: 1; /* 남은 공간을 채움 */
        height: 100%; /* 부모(body)의 높이에 맞춤 */
        width: 100%;
    }

    #chat-con{
        margin-top: 100px;
        border: 1px solid #ccc;
        width: 100%;
        height: auto;
        overflow: hidden;
        display: flex;
        margin-right: 10px; /* 유저 리스트와의 간격 */
        flex-direction: column-reverse;
    }
    #chat-log{
        padding: 10px 10px 0 10px;
        margin-bottom: 5px;
        list-style: none;
        overflow-y: auto;
        scroll-behavior: smooth;
        order: 2; /* flex-direction: column; 일 때 아래쪽에 배치 */
    }
    li {
        margin-bottom: 2px;
        padding: 5px;
        border: 1px solid #eee;
        font: 14px Consolas bold;
    }

    #input-area {
        display: flex; /* 입력창과 버튼을 가로로 나란히 */
        padding: 5px 10px;
        border-top: 1px solid #eee;
        align-items: center; /* 세로 중앙 정렬 */
        order: 1; /* flex-direction: column; 일 때 맨 아래쪽에 배치 */
        flex-shrink: 0; /* 크기가 줄어들지 않도록 고정 */
        background-color: white; /* 배경색으로 스크롤바 위로 올라오지 않도록 방지 */
    }

    #box {
        flex-grow: 1;
        margin-top: 5px;
        margin-right: 5px;
        height: 20px;
        width: auto;
        font: 16px Consolas bold;
    }

    #namebox{
        margin-top: 5px;
        margin-right: 5px;
        height: 20px;
        width: 80px;
        font: 16px Consolas bold;
    }

    #button {
        margin-top: 5px;
        height: 25px;
        width: 60px;
    }

    /* --- 유저 리스트 추가 스타일 --- */
    #user-list-area {
        margin-top: 100px;
        width: 150px; /* 유저 리스트 너비 고정 */
        border: 1px solid #ccc;
        display: flex;
        flex-direction: column;
        flex-shrink: 0; /* 유저 리스트 크기가 줄어들지 않도록 고정 */
    }
    #user-list-area h3 {
        margin: 0;
        padding: 10px;
        background-color: #f0f0f0;
        border-bottom: 1px solid #ccc;
        font-size: 16px;
    }
    #user-list {
        list-style: none;
        padding: 10px;
        margin: 0;
        overflow-y: auto; /* 유저 목록에 스크롤바 부여 */
        flex-grow: 1; /* 남은 공간을 채우도록 */
    }
    #user-list li {
        padding: 5px;
        border: none; /* 유저 리스트 li는 테두리 없음 */
        margin-bottom: 0;
        cursor: default; /* 클릭 가능한 요소 아니므로 */
        background-color: transparent;
        font: 14px Consolas bold; /* 채팅 로그 li와 동일 폰트 */
    }
</style>
</html>
<body>


<div id="chat-main-container">
    <div id="top-info-area">
        <a href="index.html" style="margin-bottom: 5px;">로비로 돌아가기</a>
        <div style="display: flex; align-items: center;">
            <p id="output" style="margin-right: 15px;">여기에 응답 표시</p>
            <div style="float:right">
            <button id="exit-button" style="margin-left: 10px;">나가기</button>
            <button id="delete-room-button" style="margin-left: 10px; background-color: #dc3545; color: white; display: none;">방 삭제</button>
            </div>
        </div>
    </div>

    <div id="chat-con">
        <ul id="chat-log">
            <li id="top-of-chat" style="height: 500px; background-color: transparent; margin: 0; padding: 0; border: none;"></li>
        </ul>

        <div id="input-area">
            <input type="text" id="namebox" name="namebox">
            <input type="text" id="box" name="box" placeholder="메시지 입력">
            <button id="button" onclick="send()">보내기</button>
        </div>
    </div>

    <div id="user-list-area">
        <h3>현재 접속자 (<span id="user-count">0</span>)</h3>
        <ul id="user-list">
        </ul>
    </div>
</div>

<!-- ================================================== -->
<!-- =========== 방 삭제 알림 모달 UI 시작 ============ -->
<!-- ================================================== -->
<div id="room-deleted-modal" style="display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center;">
    <div style="background-color: #fff; margin: auto; padding: 20px 30px 30px; border: 1px solid #888; width: 80%; max-width: 400px; border-radius: 8px; box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19); text-align: center;">
        <h2 style="color: #d9534f;">방이 삭제되었습니다</h2>
        <p>관리자에 의해 현재 채팅방이 삭제되었습니다. 아래 버튼을 눌러 로비로 돌아가주세요.</p>
        <button id="go-to-lobby-btn" style="padding: 10px 20px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 20px;">로비로 돌아가기</button>
    </div>
</div>
<!-- ================================================== -->
<!-- =========== 방 삭제 알림 모달 UI 끝 ============ -->
<!-- ================================================== -->

</body>
<script LANGUAGE="javascript" src="/sockjs.min.js"></script>
<script LANGUAGE="javascript" src="/stomp.js"></script>
<script>
	let SERVER_BASE_URL = "10.50.131.25:8080";
    SERVER_BASE_URL = "http://localhost:8080";

	// 기존 스크립트 시작 부분에 변수 선언 추가
    let isLoading = true;
	let stompClient = null;
	let username, id, nickname, role;
    let observer, firstMessageId = null, chatCount = 0, linesToLoad;
    let users = [];     // 채팅방 유저들

	const urlParams = new URLSearchParams(window.location.search);
	let roomId = urlParams.get('room'); // 'room' 쿼리 파라미터 값 가져오기

	// ... 기존 p, chatLogElement, box, button 변수들 ...
	const messageInput = document.getElementById('box'); // 기존 id "box" 사용
	const sendButton = document.getElementById('button'); // 기존 id "button" 사용
	const chatLogElement = document.getElementById('chat-log'); // 기존 id "chat-log" 사용
	const nameboxInput = document.getElementById('namebox');
	const userListElement = document.getElementById('user-list'); // 새로 추가: 유저 리스트 UL 요소
	const userCountElement = document.getElementById('user-count'); // 새로 추가: 유저 수 표시 SPAN 요소
    const topElement = document.getElementById("top-of-chat");

	// --- WebSocket/STOMP 관련 함수 추가 시작 ---

	// 웹소켓 연결 시작 (페이지 로드 또는 특정 버튼 클릭 시 호출)
	function connect() {
        // 이 예제에서는 사용자 이름을 "client"로 고정했지만, 실제로는 입력받아 사용
        // username = document.getElementById('usernameInput').value.trim(); // 사용자 입력 시 활성화

		console.log("WebSocket 연결 시도...");
		var socket = new SockJS(SERVER_BASE_URL+'/ws');
		stompClient = Stomp.over(socket);

		stompClient.heartbeat.outgoing = 0;   // 내가 보내는 하트비트(ms)
		stompClient.heartbeat.incoming = 0;   // 서버에서 기대하는 하트비트(ms)

        // STOMP 클라이언트 연결
        // 연결 성공 시 onConnected 호출, 실패 시 onError 호출
		stompClient.connect({'user_id': id, 'room_id': roomId }, onConnected, onError);

		// STOMP 클라이언트 객체가 stompClient 라고 가정합니다.
		stompClient.ws.onclose = function(event) {
			console.error('WebSocket Closed. Code:', event.code, 'Reason:', event.reason);
			// 여기에 기존의 연결 실패 처리 로직 (stompClient.debug, reconnet 등)을 추가할 수 있습니다.
			// 예를 들어:
			stompClient.debug("Whoops! Lost connection to " + this.url);
			// ... (기존 에러 처리 로직)
		};
	}

	// 연결 끊기 (필요 시)
	function disconnect() {
		if (stompClient !== null) {
			stompClient.disconnect();
		}
		console.log("Disconnected");
	}

	// STOMP 연결 성공 시 호출되는 콜백 함수
	function onConnected() {
		console.log("WebSocket 연결 성공!");
		//document.getElementById("output").textContent = "서버 응답: WebSocket 연결됨"; // 상태 표시 업데이트

        // 유저정보 받아오는 채널
        stompClient.subscribe('/topic/'+roomId+'/users', onUserInfoReceived);
        // 채팅 토픽 구독: 서버가 /topic/public으로 보내는 모든 새 메시지를 수신
		stompClient.subscribe('/topic/'+roomId+'/public', onMessageReceived);
        // 메시지 리스트를 한번에 불러오는 토픽
        stompClient.subscribe('/user/topic/queue/reply', onMessageListReceived);

        // (선택 사항) 서버에 사용자 등록 메시지 전송 (세션에 사용자 이름 저장용)
        // 백엔드 ChatStompController의 @MessageMapping("/chat.addUser")를 사용한다면
        // stompClient.send("/app/chat.addUser", {}, JSON.stringify({ sender: username }));

	}

	// STOMP 연결 실패 시 호출되는 콜백 함수
	function onError(error) {
		console.error("WebSocket 연결 실패:", error);
		document.getElementById("output").textContent = "서버 응답: WebSocket 연결 실패. " + error;
	}

    function onMessageListReceived(payload){
        const msgList = JSON.parse(payload.body).msgList;
        console.log("웹소켓으로 새 메시지리스트 수신:", msgList);

        if( msgList.length > 0 ) {
            const previousScrollHeight = chatLogElement.scrollHeight;
            const previousScrollTop = chatLogElement.scrollTop;

            msgList.forEach(msg => {
                displayMessage(msg, 0); // 받은 메시지를 화면에 표시
            });

            const newScrollHeight = chatLogElement.scrollHeight;
            chatLogElement.scrollTop = previousScrollTop + (newScrollHeight - previousScrollHeight);

            if (observer) observer.observe(topElement);
        } else {
            console.log("더 이상 불러올 메시지가 없습니다.");
            topElement.remove();
            if (observer) observer.disconnect();
        }

        isLoading = false;
    }

	// 웹소켓을 통해 새 메시지를 받았을 때 호출되는 함수
	function onMessageReceived(payload) {
		const message = JSON.parse(payload.body);
		console.log("웹소켓으로 새 메시지 수신:", message);

		displayMessage(message, 1); // 받은 메시지를 화면에 표시
	}

	// 웹소켓을 통해 새 유저정보를 받았을 때 호출되는 함수
	function onUserInfoReceived(payload) {
		const userDto = JSON.parse(payload.body);
        const userIndex = users.findIndex(user => user.id === userDto.userId );

        switch (userDto.eventType) {
            case "ENTER":
                if (userIndex === -1) {
                    // 리스트에 없으면 새로 추가
                    users.push({
                        id: userDto.userId,
                        name: userDto.nickname,
                        role: userDto.role,
                        conn: "CONNECT"
                    });
                } else {
                    // 이미 있으면 접속 상태만 변경
                    users[userIndex].conn = "CONNECT";
                }
                break; // case 종료를 잊지 마세요!

            case "EXIT": // 또는 "DISCONNECT"
                if (userIndex !== -1)
                    users[userIndex].conn = "DISCONNECT";
                break;

            case "NICK_CHANGE":
                if (userIndex !== -1) {
                    users[userIndex].name = userDto.nickname;
                    if( userDto.userId === id )
                        nickname = userDto.nickname;
                }
                break;

            case "ROOM_OUT": // 명시적 퇴장
                if (userDto.userId === id) {    // 내가 나간 경우
                    alert("방에서 퇴장했습니다. 로비로 이동합니다.");
                    window.location.href = 'index.html';
                    return; // 페이지 이동이 예정되어 있으므로 더 이상 UI 업데이트 불필요
                }

                if (userIndex !== -1) {         // 다른 사용자가 나간 경우
                    users.splice(userIndex, 1);
                }
                break;

            case "ROOM_DELETED":
                document.getElementById('room-deleted-modal').style.display = 'flex';
                return;

            case "ROLE_CHANGE":
                // 역할 변경 로직 (나중에 구현)
                break;

            default:
                // 예상치 못한 이벤트 타입 처리
                console.warn("Unknown user event type received:", userDto.eventType);
        }
        updateUserList(); // 유저 목록 UI 업데이트 함수 호출
    }

	// 새로 추가: 유저 목록 UI를 업데이트하는 함수
	function updateUserList() {
		userListElement.innerHTML = ''; // 기존 목록 비우기
		users.forEach(user => {
			const listItem = document.createElement('li');
			listItem.textContent = user.name;
            if( user.conn === "DISCONNECT" )
                listItem.style.color = "gray";
			userListElement.appendChild(listItem);
		});
		userCountElement.textContent = users.length; // 유저 수 업데이트
	}

	// --- WebSocket/STOMP 관련 함수 추가 끝 ---

	function initChat() {
        const lineHeight = getSingleLineHeight();
        const containerHeight = chatLogElement.clientHeight;
        // 몇 줄을 가져올지 계산합니다. (화면을 꽉 채우고 5줄정도 여유분 추가)
        linesToLoad = Math.ceil(containerHeight / lineHeight) + 5;

		let url = SERVER_BASE_URL+"/room/"+roomId+`/init?lines=${linesToLoad}`;

		fetch(url, {
			method: 'GET',
            credentials: 'include',
		}).then(response => {
            // 응답이 성공적인지 확인합니다 (HTTP 상태 코드 200-299).
            if (!response.ok) {
                // 응답이 실패하면 에러를 표시하고 로비로 리다이렉트.
                response.json().then(message => {
                    alert(message.message);
                    window.location.href = 'index.html';
                });
            }
            return response.json(); // JSON 응답을 기대
        }).then(data => {
            document.getElementById("output").textContent = "방 제목: "+data.roomName;

            data.users.forEach( user => {
                if( user.userId === id ) {
                    nickname = user.nickname;
                    nameboxInput.value = nickname;
                    role = user.role; // 현재 사용자의 역할 저장
                }

                users.push({id: user.userId, name: user.nickname, role: user.role, conn: user.conn});
            });

            // 역할이 ADMIN이면 방 삭제 버튼 표시
            if (role === 'ADMIN') {
                document.getElementById('delete-room-button').style.display = 'inline-block';
                document.getElementById('exit-button').hidden = true;
            }

            data.messages.slice().reverse().forEach( message => {
                if( firstMessageId === null )
                    firstMessageId = message.messageId;
                displayMessage(message, 1);
            });

			connect();
            setupIntersectionObserver();
            observer.observe(topElement);
            isLoading = false;
        })
	}

    // 화면에 메시지를 표시하는 범용 함수
    // 기존 getChat의 forEach 루프와 onMessageReceived에서 모두 사용하도록 함수 분리
    function displayMessage(message, append) {
        const listItem = document.createElement('li'); // 새로운 <li> 요소 생성
        const formattedChat = message.content.replace(/\n/g, '<br>');

        // if( message.id === "-1" ){    // message from server
        //     if( message.chat.startsWith('/') ){
        //         if( message.chat.startsWith("/clear") ){
        //             clear();
        //         }
        //     }
        // }

        // 메시지 형식 (sender가 있는 경우)

        listItem.innerHTML = message.timestamp?`[${message.timestamp.split(' ')[1]}] `:"";
        listItem.innerHTML += `<strong>${message.authorName}</strong>`;
        listItem.innerHTML += `(${message.authorId})`;
        if( isValidUrl(formattedChat) )
            listItem.innerHTML += `: <a href="${formattedChat}" target="_blank">${formattedChat}</a>`;
        else
            listItem.innerHTML += `: ${formattedChat}`;
        if( append !== 0 ){
            chatLogElement.appendChild(listItem); // ul의 끝에 li 추가
            chatLogElement.scrollTop = chatLogElement.scrollHeight; // 스크롤을 항상 최하단으로 내립니다.
        } else {
            const topMarker = document.getElementById('top-of-chat');
            if (topMarker) {
                chatLogElement.insertBefore(listItem, topMarker.nextSibling); // 마커 바로 뒤에 삽입
            } else {
                chatLogElement.prepend(listItem); // 마커가 없으면 그냥 맨 앞에 추가 (fallback)
            }
            firstMessageId = message.messageId;
            // 스크롤 위치는 유지하거나, 새로 추가된 메시지들이 보이도록 조정해야 할 수 있습니다.
            // 여기서는 스크롤 위치를 명시적으로 변경하지 않습니다. (새 메시지 로드 시 스크롤 유지)
        }
        chatCount++;
    }

	// --- 기존 send 함수는 그대로 유지 (HTTP POST로 메시지 전송) ---
	function send(){
        const messageContent = messageInput.value.trim(); // messageInput은 <input id="box">

        // 메시지 내용이 비어있으면 전송하지 않음
        if (messageContent && stompClient) {
            // 1. 서버의 ChatMessageRequestDto 형식에 맞춰 JSON 객체 생성
            const chatMessage = {
                roomId: roomId,
                authorId: id,
                content: messageContent,
                messageType: 'TEXT' // 일반 텍스트 메시지
            };

            stompClient.send("/app/chat.sendMessage", {}, JSON.stringify(chatMessage));
            messageInput.value = "";
        }
	}

	function nick(newNick){
        if( getByteLength(newNick) === 0 ){
            displayMessage({id: "", name: "system", chat: "닉네임이 너무 짧아요.", timestamp: ""});
        } else if ( getByteLength(newNick) > 22 ){
            displayMessage({id: "", name: "system", chat: "닉네임이 너무 길어요.", timestamp: ""});
        } else if (users.some(user => user.name === newNick)) {
            displayMessage({id: "", name: "system", chat: "중복된 닉네임입니다.", timestamp: ""});
        }
        else {
            const nickChange = {
                roomId: roomId,
                userId: id,
                newNickname: newNick
            };

            stompClient.send("/app/chat.changeNick", {}, JSON.stringify(nickChange));
            return;
        }
        nameboxInput.value = nickname; // 원래 닉네임으로 되돌림
	}

	function clear(){
		document.getElementById("chat-log").innerHTML = '';
    }

    function setupIntersectionObserver() {
        observer = new IntersectionObserver((entries, observer) => {
            const entry = entries[0];

            if (entry.isIntersecting && !isLoading && chatCount >= linesToLoad) {
                console.log("추가 메시지 로드 요청");
                loadMoreMessage();
            }
        }, {root: chatLogElement, rootMargin: '-1px 0px 0px 0px', threshold: 0});
    }

    function loadMoreMessage(){
        if (isLoading) return;
        isLoading = true;

        if (observer) observer.unobserve(topElement);

        const msgRequest = {
            roomId: roomId,
            beginId: firstMessageId,    // firstMessageId
            rowCount: linesToLoad       // how much need
        };

        stompClient.send("/app/chat.getMessageList", {}, JSON.stringify(msgRequest));
    }

    function exitRoom() {
        if(confirm("정말 방을 나가시겠습니까?")) {
            const url = `${SERVER_BASE_URL}/room/${roomId}/users`;

            fetch(url, {
                method: 'DELETE',
                credentials: 'include' // 세션 쿠키를 보내기 위해 필요
            })
            .then(response => {
                if (!response.ok) {
                    // 즉시 에러를 처리해야 하는 경우 (예: 권한 없음)
                    return response.json().then(err => {
                        throw new Error(err.message || '나가기 요청에 실패했습니다.');
                    });
                }
                console.log("나가기 요청을 성공적으로 보냈습니다. 서버의 ROOM_OUT 이벤트를 기다립니다.");
            })
            .catch(error => {
                console.error('Error sending exit request:', error);
                alert(error.message);
            });
        }
    }

    function deleteRoom() {
        if(confirm("정말로 방을 삭제하시겠습니까? 모든 대화 내용이 사라지고, 현재 접속 중인 멤버들은 방에서 나가게 됩니다.")) {
            const url = `${SERVER_BASE_URL}/room/${roomId}`;

            fetch(url, {
                method: 'DELETE',
                credentials: 'include'
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => {
                        throw new Error(err.message || '방 삭제 요청에 실패했습니다.');
                    });
                }
                // 성공적으로 요청을 보냈으므로, 서버로부터 ROOM_DELETED 이벤트를 기다립니다.
                console.log("방 삭제 요청을 성공적으로 보냈습니다.");
            })
            .catch(error => {
                console.error('Error deleting room:', error);
                alert(error.message);
            });
        }
    }

	// --- 이벤트 리스너 및 초기 호출 ---
	document.getElementById('box').addEventListener('keydown', (event) => {
		if (event.key === 'Enter')
			send();
	});
	document.getElementById('namebox').addEventListener('keydown', (event) => {
		if (event.key === 'Enter' || event.keyCode === 13) {
			document.getElementById('namebox').blur();
		}
	});

	document.getElementById('namebox').addEventListener('change', (event) => {
// /chat/nick 보내기
		nick(nameboxInput.value);
	});

	document.addEventListener('DOMContentLoaded', function(){
        document.getElementById('exit-button').addEventListener('click', exitRoom);
        document.getElementById('delete-room-button').addEventListener('click', deleteRoom);
        document.getElementById('go-to-lobby-btn').addEventListener('click', () => {
            window.location.href = 'index.html';
        });

        // 페이지 로드 시 로그인 상태를 확인하는 함수
        function checkLoginStatus() {
            fetch(`${SERVER_BASE_URL}/auth/session`, { method: 'POST', credentials: 'include' })
                .then(response => {
                    if (!response.ok) {
                        // 4xx, 5xx 에러 발생 시 로그인되지 않은 상태로 간주
                        // 서버가 보낸 에러 메시지를 확인하고 싶다면 response.json()을 사용
                        return response.json().then(err => { throw err; });
                    }
                    return response.json(); // 성공 시 LoginResponseDto를 파싱
                })
                .then(userData => {
                    // 성공적으로 사용자 정보를 받으면, 다음단계로
                    id = userData.userId;
                    username = userData.username;
                    initChat();
                })
                .catch(error => {
                    // 로그인되지 않은 상태이므로 로비로 리다이렉트
                    alert('세션 확인 결과: 로그인되지 않음.');
                    window.location.href = 'index.html';
                });
        }

        checkLoginStatus();
    });

    function getByteLength(str) {
        return new TextEncoder().encode(str).length;
    }

	function isValidUrl(str) {
        try {
            const url = new URL(str);
            // http: 또는 https: 프로토콜만 허용하려면 아래 조건을 추가할 수 있습니다.
            return url.protocol === 'http:' || url.protocol === 'https:';
        } catch (e) {
            // URL 객체 생성 중 오류가 발생하면 유효하지 않은 URL로 판단
            return false;
        }
	}

    function getSingleLineHeight() {
        // 임시로 li 요소를 하나 만들어서 높이를 측정하고 삭제하는 방식
        const tempLi = document.createElement('li');
        // 화면에 보이지 않도록 스타일 설정
        tempLi.style.visibility = 'hidden';
        tempLi.style.position = 'absolute';
        tempLi.innerHTML = 'Sample'; // 내용물은 중요하지 않음

        document.body.appendChild(tempLi);
        const lineHeight = tempLi.offsetHeight; // padding, border 포함한 실제 높이
        document.body.removeChild(tempLi); // 측정 후 삭제

        return lineHeight > 0 ? lineHeight : 18; // 만약 측정이 안되면 기본값 18px 반환
    }


</script>