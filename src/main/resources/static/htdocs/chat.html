<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simple Chat</title>
</head>
<style>
    #chat-con{
        border: 1px solid #ccc;
        width: 520px;
        height: 500px;
        overflow: hidden;
        display: flex;
        flex-direction: column-reverse;
    }
    #chat-log{
        padding: 10px 10px 0 10px;
        margin-bottom: 5px;
        list-style: none;
        overflow-y: auto;
        scroll-behavior: smooth;
    }
    li {
        margin-bottom: 2px;
        padding: 5px;
        border: 1px solid #eee;
        font: 14px Consolas bold;
    }
    #box {
        margin-top: 5px;
        height: 20px;
        font: 16px Consolas bold;
    }
    #namebox{
        margin-top: 5px;
        height: 20px;
        font: 16px Consolas bold;
    }

    #button {
        padding-top: 5px;
    }
</style>
</html>
<body>
<p id="output">여기에 응답 표시</p>
<a href="index.html">로비로 돌아가기</a>
<div id="chat-con">
    <ul id="chat-log"></ul>
</div>
<input type="text" size=2 id="namebox" name="namebox">
<input type="text" size=40 id="box" name="box" placeholder="메시지 입력">
<button id="button" onclick=send()>보내기</button>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.js"></script>
<script>
	let server = 'localhost:8080';//"10.50.131.25:8080";

	// 기존 스크립트 시작 부분에 변수 선언 추가
	let stompClient = null;
	let username = localStorage.getItem("nick"); // 사용자 이름을 고정하거나 입력받도록 조정
	let id = localStorage.getItem("id");  // 내부적으로, 통신할때만 사용

	const urlParams = new URLSearchParams(window.location.search);
	let roomname = urlParams.get('room'); // 'room' 쿼리 파라미터 값 가져오기

	// ... 기존 p, chatLogElement, box, button 변수들 ...
	const messageInput = document.getElementById('box'); // 기존 id "box" 사용
	const sendButton = document.getElementById('button'); // 기존 id "button" 사용
	const chatLogElement = document.getElementById('chat-log'); // 기존 id "chat-log" 사용
	const nameboxInput = document.getElementById('namebox');


	// --- WebSocket/STOMP 관련 함수 추가 시작 ---

	// 웹소켓 연결 시작 (페이지 로드 또는 특정 버튼 클릭 시 호출)
	function connect() {
// 이 예제에서는 사용자 이름을 "client"로 고정했지만, 실제로는 입력받아 사용
// username = document.getElementById('usernameInput').value.trim(); // 사용자 입력 시 활성화

		console.log("WebSocket 연결 시도...");
		var socket = new SockJS('http://'+server+'/ws');
		stompClient = Stomp.over(socket);

// STOMP 클라이언트 연결
// 연결 성공 시 onConnected 호출, 실패 시 onError 호출
		stompClient.connect({}, onConnected, onError);
	}

	// STOMP 연결 성공 시 호출되는 콜백 함수
	function onConnected() {
		console.log("WebSocket 연결 성공!");
		document.getElementById("output").textContent = "서버 응답: WebSocket 연결됨"; // 상태 표시 업데이트

// 1. 공용 채팅 토픽 구독: 서버가 /topic/public으로 보내는 모든 새 메시지를 수신
		stompClient.subscribe('/topic/'+roomname+'/public', onMessageReceived);

// (선택 사항) 서버에 사용자 등록 메시지 전송 (세션에 사용자 이름 저장용)
// 백엔드 ChatStompController의 @MessageMapping("/chat.addUser")를 사용한다면
// stompClient.send("/app/chat.addUser", {}, JSON.stringify({ sender: username }));

// 초기 채팅 내역은 기존 getChat() 함수 (fetch)를 통해 가져옵니다.
		getChat("http://"+server+"/"+roomname);
		document.getElementById("output").textContent = "방 제목: "+roomname
	}

	// STOMP 연결 실패 시 호출되는 콜백 함수
	function onError(error) {
		console.error("WebSocket 연결 실패:", error);
		document.getElementById("output").textContent = "서버 응답: WebSocket 연결 실패. " + error;
	}

	// 웹소켓을 통해 새 메시지를 받았을 때 호출되는 함수
	function onMessageReceived(payload) {
		const message = JSON.parse(payload.body);
		console.log("웹소켓으로 새 메시지 수신:", message);

		displayMessage(message); // 받은 메시지를 화면에 표시
	}

	function onNickChanged(payload){
		const flag = payload.body;
		console.log("웹소켓으로 새 메시지 수신:", flag);
		if( flag.includes(username) ) {
			if (flag.split('/')[1] === "1") {
				nameboxInput.value = username;
				alert("중복닉네임 입니다.");
			} else
				username = nameboxInput.value;
		}
	}

	// 화면에 메시지를 표시하는 범용 함수
	// 기존 getChat의 forEach 루프와 onMessageReceived에서 모두 사용하도록 함수 분리
	function displayMessage(message) {
		const listItem = document.createElement('li'); // 새로운 <li> 요소 생성
		const formattedChat = message.chat.replace(/\n/g, '<br>');

		if( message.id === "-1" ){    // message from server
			if( message.chat.startsWith('/') ){
				if( message.chat.startsWith("/clear") ){
					clear();
				}
			}
		}

// 메시지 형식 (sender가 있는 경우)
        listItem.innerHTML = message.timestamp?`[${message.timestamp.split(' ')[1]}]`:"";
		listItem.innerHTML += `<strong>${message.name}</strong>`;
        listItem.innerHTML += message.id?`(${message.id})`:"";
        listItem.innerHTML += `: ${formattedChat}`;
        chatLogElement.appendChild(listItem); // ul에 li 추가
		chatLogElement.scrollTop = chatLogElement.scrollHeight; // 스크롤을 항상 최하단으로 내립니다.
	}
	// --- WebSocket/STOMP 관련 함수 추가 끝 ---


	// --- 기존 getChat 함수 수정 ---
	// 이제 이 함수는 초기 메시지 로딩 시 한 번만 호출됩니다.
	// 기존의 `p.textContent = "서버 응답: " + data;` 부분은 웹소켓 연결 상태를 표시하는 것으로 대체될 수 있습니다.
	// function getChat(url="http://localhost:8080/init"){ // URL을 /init으로 고정
	//   fetch(url)
	//           .then(response => response.json()) // JSON 응답을 기대
	//           .then(data => {
	//             // p.textContent = "서버 응답: " + data.length + "개 초기 메시지"; // 상태창은 웹소켓이 관리
	//             // 기존 메시지들 비우고 다시 로드 (선택 사항: 아니면 새로고침 없이 계속 쌓이도록)
	//             chatLogElement.innerHTML = '';
	//             data.forEach(message => {
	//               displayMessage(message); // 받은 메시지를 화면에 표시
	//             });
	//           })
	//           .catch(error => console.error('Error fetching initial chat history:', error));
	// }
	function getChat(url = "http://"+server+"/"+roomname) {
        // POST 요청에 보낼 데이터를 객체로 정의합니다.
        // 이 예시에서는 빈 객체를 보냅니다.
        // 실제 서버 로직에 따라 필요한 데이터를 추가할 수 있습니다.

		const requestBody = {};
		fetch(url, {
			method: 'POST', // HTTP 요청 메서드를 POST로 지정합니다.
			headers: {
				'Content-Type': 'application/x-www-form-urlencoded'  // 서버에 JSON 데이터를 보낼 것임을 알립니다.
			},
            body: new URLSearchParams({
				id: id===null?"-1":id      // localStorage에 들어있던 id, 없으면 -1
		    })
		})
			.then(response => {
				// 응답이 성공적인지 확인합니다 (HTTP 상태 코드 200-299).
				if (!response.ok) {
					// 응답이 실패하면 에러를 던져 .catch 블록으로 넘깁니다.
					throw new Error(`HTTP error! status: ${response.status}`);
				}
				return response.json(); // JSON 응답을 기대
			})
			.then(data => {
				// chatLogElement는 HTML에 존재하는 채팅 로그를 표시할 요소여야 합니다.
				// 예를 들어, const chatLogElement = document.getElementById('chat-log');
				chatLogElement.innerHTML = ''; // 기존 메시지들 비우고 다시 로드
				data.forEach(message => {
					if( message.messageNum === -1 ) {
						nameboxInput.value = message.chat;
						username = message.chat;
						id = parseInt(message.id);
						localStorage.setItem("id", id);
                        localStorage.setItem("nick", username);
					}
					else
						displayMessage(message); // 받은 메시지를 화면에 표시 (displayMessage 함수는 별도로 정의되어 있어야 함)
				});
			})
			.catch(error => console.error('Error fetching initial chat history:', error));
	}


	// --- 기존 send 함수는 그대로 유지 (HTTP POST로 메시지 전송) ---
	function send(){
		let chat = document.getElementById('box').value;
		document.getElementById('box').value = "";

		if( chat.startsWith('/') ){   // 슬래시 명령어 실행
			let sp = chat.split(' ')
			if( sp[0].localeCompare("/enter") === 0 ){
				roomname = sp[1];
				connect();
			} else if( sp[0].localeCompare("/clear") === 0 ){
				clear();
			} else if( sp[0].localeCompare("/nick") === 0 ){
                nick(sp[1]);
            }
			return;
		}

		const response = fetch('http://'+server+'/'+roomname+'/chat', {    // chat = 방 이름
			method: 'POST',
			headers: {
				'Content-Type': 'application/x-www-form-urlencoded'
			},
			body: new URLSearchParams({
				id: id,
				message: chat // "message"는 서버 컨트롤러의 @RequestParam 이름과 일치
			})
		});

	}

	function nick(newNick){
        if( getByteLength(newNick) === 0 ){
            displayMessage({id: "", name: "system", chat: "닉네임이 너무 짧아요.", timestamp: ""});
        } else if ( getByteLength(newNick) > 22 ){
            displayMessage({id: "", name: "system", chat: "닉네임이 너무 길어요.", timestamp: ""});
        } else {
            username = newNick;
            const response = fetch('http://'+server+'/'+roomname+'/nick', {    // chat = 방 이름
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: new URLSearchParams({
                    id: id,
                    nick: username // "nick"는 서버 컨트롤러의 @RequestParam 이름과 일치
                })
            });
            localStorage.setItem("nick", username);
        }
        nameboxInput.value = username;
	}

	function clear(){
		document.getElementById("chat-log").innerHTML = '';
    }

	// --- 이벤트 리스너 및 초기 호출 ---
	document.getElementById('box').addEventListener('keydown', (event) => {
		if (event.key === 'Enter')
			send();
	});

	document.getElementById('namebox').addEventListener('keydown', (event) => {
		if (event.key === 'Enter' || event.keyCode === 13) {
			document.getElementById('namebox').blur();
		}
	});

	document.getElementById('namebox').addEventListener('change', (event) => {
// /chat/nick 보내기
		nick(nameboxInput.value);
	});

	// 페이지 로드 시 웹소켓 연결 시작
	document.addEventListener('DOMContentLoaded', connect); // 이제 페이지 로드 시 바로 연결 시작
	// setInterval(getChat, 1000); // 숏폴링은 이제 사용하지 않음

    function getByteLength(str) {
        return new TextEncoder().encode(str).length;
    }
</script>